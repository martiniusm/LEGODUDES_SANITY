{"version":3,"file":"cliWorker-CGMJciDK.js","sources":["../../src/util/cliWorker.ts"],"sourcesContent":["import path from 'path'\nimport pkgDir from 'pkg-dir'\n\n/**\n * Because we're bundling the CLI into a single file, the classic approach of\n * checking `isMainThread()` and spawning a thread on `__dirname` does not work,\n * as it leads to the entire CLI being re-executed in the worker thread.\n *\n * To make things worse, the built CLI makes it difficult to resolve paths to\n * built source files (that contains the unpackaged worker).\n *\n * This function takes a path relative to the `src/workers` folder, resolves\n * the location of that within the installed location (eg global Sanity CLI)\n * and ensures we can resolve the actual module before trying to spawn the\n * worker thread.\n *\n * @param workerPath - _RELATIVE_ path (relative to `src/workers`) to the worker\n * @returns Full, absolute path to the worker\n * @internal\n */\nexport async function getCliWorkerPath(workerPath: string): Promise<string> {\n  const cliDir = await pkgDir(__dirname)\n  if (!cliDir) {\n    throw new Error('Failed to find root @sanity/cli module directory')\n  }\n\n  const resolvedPath = path.resolve(cliDir, 'lib', 'workers', workerPath)\n  try {\n    return require.resolve(resolvedPath)\n  } catch (err) {\n    throw new Error(`Unable to resolve path for worker: ${workerPath}`)\n  }\n}\n"],"names":["getCliWorkerPath","workerPath","cliDir","pkgDir","__dirname","Error","resolvedPath","path","resolve","require","err","concat"],"mappings":";;;;;;;;;;;AAoBA,eAAsBA,iBAAiBC,UAAqC,EAAA;EACpE,MAAAC,MAAA,GAAS,MAAMC,uBAAA,CAAOC,SAAS,CAAA;EACrC,IAAI,CAACF,MAAQ,EAAA;IACL,MAAA,IAAIG,MAAM,kDAAkD,CAAA;EACpE;EAEA,MAAMC,eAAeC,aAAAA,CAAAA,OAAK,CAAAC,OAAA,CAAQN,MAAQ,EAAA,KAAA,EAAO,WAAWD,UAAU,CAAA;EAClE,IAAA;IACK,OAAAQ,OAAA,CAAQD,QAAQF,YAAY,CAAA;WAC5BI,GAAK,EAAA;IACZ,MAAM,IAAIL,KAAA,uCAAAM,MAAA,CAA4CV,UAAU,CAAE,CAAA;EACpE;AACF;"}