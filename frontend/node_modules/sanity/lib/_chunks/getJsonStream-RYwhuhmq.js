import { jsx, jsxs } from 'react/jsx-runtime';
import { Button as Button$1, Dialog as Dialog$1, Flex, Box, MenuButton as MenuButton$1, MenuGroup as MenuGroup$1, Text, Stack, Hotkeys, Badge, MenuItem as MenuItem$1, Popover as Popover$1, Tab as Tab$1, Tooltip as Tooltip$1, TooltipDelayGroupProvider as TooltipDelayGroupProvider$1, Card, Grid, TextInput, useForwardedRef, Select } from '@sanity/ui';
import { forwardRef, useCallback, useMemo, isValidElement, createElement, createContext, useContext, useState, useEffect } from 'react';
import { ChevronLeftIcon, ChevronRightIcon } from '@sanity/icons';
import { getWeek, startOfMonth, eachWeekOfInterval, lastDayOfMonth, addDays, isSameDay, isSameMonth, setDate, setMonth, addMonths, setYear, setMinutes, setHours } from 'date-fns';
import range from 'lodash/range.js';
import styled from 'styled-components';
import { useTranslation } from 'react-i18next';
import { isValidElementType } from 'react-is';
function ConditionalWrapper(_ref) {
  let {
    children,
    condition,
    wrapper
  } = _ref;
  if (!condition) {
    return children;
  }
  return wrapper(children);
}
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", {
  value: __freeze$1(raw || cooked.slice())
}));
var _a$1;
const LARGE_BUTTON_PROPS = {
  space: 3,
  padding: 3
};
const DEFAULT_BUTTON_PROPS = {
  space: 2,
  padding: 2
};
const TooltipButtonWrapper = styled.span(_a$1 || (_a$1 = __template$1(["\n  display: inline-flex;\n"])));
const Button = forwardRef(function Button2(_ref2, ref) {
  let {
    size = "default",
    mode = "default",
    paddingY,
    tone = "default",
    tooltipProps,
    ...rest
  } = _ref2;
  const renderWrapper = useCallback(children => {
    return /* @__PURE__ */jsx(Tooltip, {
      content: tooltipProps == null ? void 0 : tooltipProps.content,
      portal: true,
      ...tooltipProps,
      children: /* @__PURE__ */jsx(TooltipButtonWrapper, {
        children
      })
    });
  }, [tooltipProps]);
  const sizeProps = size === "default" ? DEFAULT_BUTTON_PROPS : LARGE_BUTTON_PROPS;
  return /* @__PURE__ */jsx(ConditionalWrapper, {
    condition: !!tooltipProps,
    wrapper: renderWrapper,
    children: /* @__PURE__ */jsx(Button$1, {
      ...rest,
      ...sizeProps,
      paddingY,
      ref,
      mode,
      tone
    })
  });
});
const Dialog = forwardRef(function Dialog2(_ref3, ref) {
  let {
    bodyHeight,
    children,
    footer,
    padding = true,
    ...props
  } = _ref3;
  const {
    t
  } = useTranslation();
  return /* @__PURE__ */jsx(Dialog$1, {
    ...props,
    animate: true,
    ref,
    footer: ((footer == null ? void 0 : footer.confirmButton) || (footer == null ? void 0 : footer.cancelButton)) && /* @__PURE__ */jsxs(Flex, {
      width: "full",
      gap: 3,
      justify: "flex-end",
      padding: 3,
      children: [props.onClose && /* @__PURE__ */jsx(Button$1, {
        mode: "bleed",
        padding: 2,
        text: t("common.dialog.cancel-button.text"),
        tone: "default",
        onClick: props.onClose,
        ...footer.cancelButton
      }), footer.confirmButton && /* @__PURE__ */jsx(Button$1, {
        mode: "default",
        padding: 2,
        text: t("common.dialog.confirm-button.text"),
        tone: "critical",
        ...footer.confirmButton
      })]
    }),
    children: /* @__PURE__ */jsx(Box, {
      height: bodyHeight,
      padding: padding ? 4 : 0,
      children
    })
  });
});
const MenuButton = forwardRef(function MenuButton2(props, ref) {
  return /* @__PURE__ */jsx(MenuButton$1, {
    ...props,
    ref,
    popover: {
      ...props.popover,
      animate: true
    }
  });
});
const MenuGroup = props => {
  return /* @__PURE__ */jsx(MenuGroup$1, {
    ...props,
    fontSize: 1,
    padding: 3
  });
};
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", {
  value: __freeze(raw || cooked.slice())
}));
var _a, _b;
const FONT_SIZE = 1;
const SUBTITLE_FONT_SIZE = 0;
const SubtitleText = styled(Text)(_a || (_a = __template(["\n  margin-top: 2px;\n"])));
const PreviewWrapper = styled(Box)(_b || (_b = __template(["\n  height: 25px;\n  width: 25px;\n  overflow: hidden;\n"])));
const MenuItem = forwardRef(function MenuItem2(_ref4, ref) {
  let {
    badgeText,
    children: childrenProp,
    disabled,
    hotkeys,
    icon,
    iconRight,
    preview = null,
    renderMenuItem,
    text,
    tooltipProps,
    __unstable_subtitle,
    __unstable_space,
    ...rest
  } = _ref4;
  const menuItemContent = useMemo(() => {
    return /* @__PURE__ */jsxs(Flex, {
      align: "center",
      gap: 2,
      children: [preview && /* @__PURE__ */jsx(PreviewWrapper, {
        style: {
          opacity: disabled ? 0.25 : void 0
        },
        paddingRight: __unstable_space ? 1 : 0,
        children: /* @__PURE__ */jsx(Flex, {
          align: "center",
          height: "fill",
          justify: "center",
          children: preview
        })
      }), icon && /* @__PURE__ */jsx(Box, {
        paddingRight: 1,
        children: /* @__PURE__ */jsxs(Text, {
          size: FONT_SIZE,
          children: [isValidElement(icon) && icon, isValidElementType(icon) && createElement(icon)]
        })
      }), text && /* @__PURE__ */jsxs(Stack, {
        flex: 1,
        space: __unstable_subtitle ? 1 : 2,
        paddingLeft: __unstable_subtitle ? 1 : 0,
        children: [/* @__PURE__ */jsx(Text, {
          size: FONT_SIZE,
          textOverflow: "ellipsis",
          weight: "medium",
          children: text
        }), __unstable_subtitle && /* @__PURE__ */jsx(SubtitleText, {
          size: SUBTITLE_FONT_SIZE,
          textOverflow: "ellipsis",
          weight: "medium",
          muted: true,
          children: __unstable_subtitle
        })]
      }), (badgeText || hotkeys || iconRight) && /* @__PURE__ */jsxs(Flex, {
        align: "center",
        gap: 3,
        marginLeft: 3,
        children: [hotkeys && /* @__PURE__ */jsx(Hotkeys, {
          keys: hotkeys,
          style: {
            marginTop: -4,
            marginBottom: -4
          }
        }), badgeText && /* @__PURE__ */jsx(Badge, {
          fontSize: 0,
          style: {
            marginTop: -4,
            marginBottom: -4
          },
          children: badgeText
        }), iconRight && /* @__PURE__ */jsxs(Text, {
          size: FONT_SIZE,
          children: [isValidElement(iconRight) && iconRight, isValidElementType(iconRight) && createElement(iconRight)]
        })]
      })]
    });
  }, [preview, disabled, __unstable_space, icon, text, __unstable_subtitle, badgeText, hotkeys, iconRight]);
  const renderWrapper = useCallback(children => {
    return /* @__PURE__ */jsx(Tooltip, {
      content: tooltipProps == null ? void 0 : tooltipProps.content,
      portal: true,
      ...tooltipProps,
      children: /* @__PURE__ */jsx("div", {
        children
      })
    });
  }, [tooltipProps]);
  return /* @__PURE__ */jsx(ConditionalWrapper, {
    condition: !!tooltipProps,
    wrapper: renderWrapper,
    children: /* @__PURE__ */jsx(MenuItem$1, {
      disabled,
      paddingLeft: preview ? 1 : 3,
      paddingRight: 3,
      paddingY: preview ? 1 : 3,
      ref,
      ...rest,
      children: typeof childrenProp === "undefined" && typeof renderMenuItem === "function" ? renderMenuItem(menuItemContent) : menuItemContent
    })
  });
});
const Popover = forwardRef(function Popover2(props, ref) {
  return /* @__PURE__ */jsx(Popover$1, {
    ...props,
    animate: true,
    ref
  });
});
const Tab = forwardRef(function Tab2(_ref5, ref) {
  let {
    tone = "default",
    ...props
  } = _ref5;
  return /* @__PURE__ */jsx(Tab$1, {
    ...props,
    muted: true,
    padding: 2,
    ref,
    tone
  });
});
const TOOLTIP_DELAY_PROPS = {
  open: 400
};
const TOOLTIP_SHARED_PROPS = {
  animate: true,
  arrow: false,
  boundaryElement: null,
  delay: TOOLTIP_DELAY_PROPS,
  fallbackPlacements: ["bottom-start", "bottom-end", "top-start", "top-end"],
  placement: "bottom",
  portal: true
};
const Tooltip = forwardRef(function Tooltip2(props, ref) {
  const {
    content,
    hotkeys,
    ...rest
  } = props;
  if (typeof content === "string") {
    return /* @__PURE__ */jsx(Tooltip$1, {
      ...TOOLTIP_SHARED_PROPS,
      content: /* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [content && /* @__PURE__ */jsx(Box, {
          flex: 1,
          padding: 1,
          children: /* @__PURE__ */jsx(Text, {
            size: 1,
            children: content
          })
        }), hotkeys && /* @__PURE__ */jsx(Box, {
          flex: "none",
          children: /* @__PURE__ */jsx(Hotkeys, {
            keys: hotkeys
          })
        })]
      }),
      padding: 1,
      ref,
      ...rest
    });
  }
  return /* @__PURE__ */jsx(Tooltip$1, {
    ...TOOLTIP_SHARED_PROPS,
    content,
    ref,
    ...rest
  });
});
const TooltipDelayGroupProvider = props => {
  return /* @__PURE__ */jsx(TooltipDelayGroupProvider$1, {
    delay: TOOLTIP_DELAY_PROPS,
    children: props.children
  });
};
const LocaleContext = createContext(void 0);
function useCurrentLocale() {
  return useLocale().currentLocale;
}
function useLocale() {
  const context = useContext(LocaleContext);
  if (!context) {
    throw new Error("Sanity LocaleContext value missing. Is this hook being used outside LocaleContext.Provider?");
  }
  return context;
}
function CalendarDay(props) {
  const {
    date,
    focused,
    isCurrentMonth,
    isToday,
    onSelect,
    selected
  } = props;
  const handleClick = useCallback(() => {
    onSelect(date);
  }, [date, onSelect]);
  return /* @__PURE__ */jsx("div", {
    "aria-selected": selected,
    "data-ui": "CalendarDay",
    children: /* @__PURE__ */jsx(Card, {
      "aria-label": date.toDateString(),
      "aria-pressed": selected,
      as: "button",
      __unstable_focusRing: true,
      "data-weekday": true,
      "data-focused": focused ? "true" : "",
      role: "button",
      tabIndex: -1,
      onClick: handleClick,
      padding: 2,
      radius: 2,
      selected,
      tone: isToday || selected ? "primary" : "default",
      children: /* @__PURE__ */jsx(Text, {
        muted: !selected && !isCurrentMonth,
        size: 1,
        style: {
          textAlign: "center"
        },
        weight: isCurrentMonth ? "medium" : "regular",
        children: date.getDate()
      })
    })
  });
}
const HOURS_24 = range(0, 24);
const ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
const TAIL_WEEKDAYS = [1, 2, 3, 4, 5, 6];
const getWeekStartsOfMonth = (date, weekStartsOn) => {
  const firstDay = startOfMonth(date);
  return eachWeekOfInterval({
    start: firstDay,
    end: lastDayOfMonth(firstDay)
  }, {
    weekStartsOn: weekStartsOn === 7 ? 0 : weekStartsOn
  });
};
const getWeekDaysFromWeekStarts = weekStarts => {
  return weekStarts.map(weekStart => [weekStart, ...TAIL_WEEKDAYS.map(d => addDays(weekStart, d))]);
};
const useWeeksOfMonth = date => {
  const {
    weekInfo
  } = useCurrentLocale();
  return getWeekDaysFromWeekStarts(getWeekStartsOfMonth(date, weekInfo.firstDay)).map(days => ({
    number: getWeek(days[0]),
    days
  }));
};
function CalendarMonth(props) {
  const {
    weekInfo: {
      firstDay: weekStartDay
    }
  } = useCurrentLocale();
  const weekDayNames = weekStartDay === 1 ? props.weekDayNames : [props.weekDayNames[6], ...props.weekDayNames.slice(0, 6)];
  return /* @__PURE__ */jsx(Box, {
    "aria-hidden": props.hidden || false,
    "data-ui": "CalendarMonth",
    children: /* @__PURE__ */jsxs(Grid, {
      gap: 1,
      style: {
        gridTemplateColumns: "repeat(7, minmax(44px, 46px))"
      },
      children: [weekDayNames.map(weekday => /* @__PURE__ */jsx(Box, {
        paddingY: 2,
        children: /* @__PURE__ */jsx(Text, {
          size: 1,
          weight: "medium",
          style: {
            textAlign: "center"
          },
          children: weekday
        })
      }, weekday)), useWeeksOfMonth(props.date).map((week, weekIdx) => week.days.map((date, dayIdx) => {
        const focused = props.focused && isSameDay(date, props.focused);
        const selected = props.selected && isSameDay(date, props.selected);
        const isToday = isSameDay(date, /* @__PURE__ */new Date());
        const isCurrentMonth = props.focused && isSameMonth(date, props.focused);
        return /* @__PURE__ */jsx(CalendarDay, {
          date,
          focused,
          isCurrentMonth,
          isToday,
          onSelect: props.onSelect,
          selected
        }, "".concat(weekIdx, "-").concat(dayIdx));
      }))]
    })
  });
}
const features = {
  dayPresets: false,
  timePresets: false
};
const LazyTextInput = forwardRef(function LazyTextInput2(_ref6, forwardedRef) {
  let {
    onChange,
    onBlur,
    onKeyPress,
    value,
    ...rest
  } = _ref6;
  const [inputValue, setInputValue] = useState();
  const handleChange = useCallback(event => {
    setInputValue(event.currentTarget.value);
  }, []);
  const checkEvent = useCallback(event => {
    const currentValue = event.currentTarget.value;
    if (currentValue !== "".concat(value)) {
      if (onChange) {
        onChange(event);
      }
    }
    setInputValue(void 0);
  }, [onChange, value]);
  const handleBlur = useCallback(e => {
    checkEvent(e);
    if (onBlur) {
      onBlur(e);
    }
  }, [checkEvent, onBlur]);
  const handleKeyPress = useCallback(e => {
    if (e.key === "Enter") {
      checkEvent(e);
    }
    if (onKeyPress) {
      onKeyPress(e);
    }
  }, [checkEvent, onKeyPress]);
  return /* @__PURE__ */jsx(TextInput, {
    ...rest,
    "data-testid": "date-input",
    ref: forwardedRef,
    value: inputValue === void 0 ? value : inputValue,
    onChange: handleChange,
    onBlur: handleBlur,
    onKeyPress: handleKeyPress
  });
});
const YearInput = props => {
  const {
    onChange,
    ...restProps
  } = props;
  const handleChange = useCallback(event => {
    const numericValue = parseInt(event.currentTarget.value, 10);
    if (!isNaN(numericValue)) {
      onChange(numericValue);
    }
  }, [onChange]);
  return /* @__PURE__ */jsx(LazyTextInput, {
    ...restProps,
    fontSize: 1,
    onChange: handleChange,
    inputMode: "numeric",
    padding: 2,
    radius: 2
  });
};
const PRESERVE_FOCUS_ELEMENT = /* @__PURE__ */jsx("span", {
  "data-preserve-focus": true,
  style: {
    overflow: "hidden",
    position: "absolute",
    outline: "none"
  },
  tabIndex: -1
});
const CALENDAR_ICON_BUTTON_PROPS = {
  padding: 2
};
const Calendar = forwardRef(function Calendar2(props, forwardedRef) {
  const {
    selectTime,
    onFocusedDateChange,
    selectedDate = /* @__PURE__ */new Date(),
    focusedDate = selectedDate,
    timeStep = 1,
    onSelect,
    labels,
    ...restProps
  } = props;
  const setFocusedDate = useCallback(date => onFocusedDateChange(date), [onFocusedDateChange]);
  const setFocusedDateMonth = useCallback(month => setFocusedDate(setDate(setMonth(focusedDate, month), 1)), [focusedDate, setFocusedDate]);
  const handleFocusedMonthChange = useCallback(e => setFocusedDateMonth(Number(e.currentTarget.value)), [setFocusedDateMonth]);
  const moveFocusedDate = useCallback(by => setFocusedDate(addMonths(focusedDate, by)), [focusedDate, setFocusedDate]);
  const setFocusedDateYear = useCallback(year => setFocusedDate(setYear(focusedDate, year)), [focusedDate, setFocusedDate]);
  const handleDateChange = useCallback(date => {
    onSelect(setMinutes(setHours(date, selectedDate.getHours()), selectedDate.getMinutes()));
  }, [onSelect, selectedDate]);
  const handleMinutesChange = useCallback(event => {
    const m = Number(event.currentTarget.value);
    onSelect(setMinutes(selectedDate, m));
  }, [onSelect, selectedDate]);
  const handleHoursChange = useCallback(event => {
    const m = Number(event.currentTarget.value);
    onSelect(setHours(selectedDate, m));
  }, [onSelect, selectedDate]);
  useCallback((hours, mins) => {
    onSelect(setHours(setMinutes(selectedDate, mins), hours));
  }, [onSelect, selectedDate]);
  const ref = useForwardedRef(forwardedRef);
  const focusCurrentWeekDay = useCallback(() => {
    var _a, _b;
    (_b = (_a = ref.current) == null ? void 0 : _a.querySelector('[data-focused="true"]')) == null ? void 0 : _b.focus();
  }, [ref]);
  const handleKeyDown = useCallback(event => {
    var _a, _b;
    if (!ARROW_KEYS.includes(event.key)) {
      return;
    }
    const target = event.currentTarget;
    event.preventDefault();
    if (target.hasAttribute("data-calendar-grid")) {
      focusCurrentWeekDay();
      return;
    }
    if (event.key === "ArrowUp") {
      onFocusedDateChange(addDays(focusedDate, -7));
    }
    if (event.key === "ArrowDown") {
      onFocusedDateChange(addDays(focusedDate, 7));
    }
    if (event.key === "ArrowLeft") {
      onFocusedDateChange(addDays(focusedDate, -1));
    }
    if (event.key === "ArrowRight") {
      onFocusedDateChange(addDays(focusedDate, 1));
    }
    (_b = (_a = ref.current) == null ? void 0 : _a.querySelector("[data-preserve-focus]")) == null ? void 0 : _b.focus();
  }, [ref, focusCurrentWeekDay, onFocusedDateChange, focusedDate]);
  useEffect(() => {
    focusCurrentWeekDay();
  }, [focusCurrentWeekDay]);
  useEffect(() => {
    var _a;
    const currentFocusInCalendarGrid = (_a = document.activeElement) == null ? void 0 : _a.matches("[data-calendar-grid], [data-calendar-grid] [data-preserve-focus]");
    if (
    // Only move focus if it's currently in the calendar grid
    currentFocusInCalendarGrid) {
      focusCurrentWeekDay();
    }
  }, [ref, focusCurrentWeekDay, focusedDate]);
  useCallback(() => handleDateChange(addDays( /* @__PURE__ */new Date(), -1)), [handleDateChange]);
  useCallback(() => handleDateChange( /* @__PURE__ */new Date()), [handleDateChange]);
  useCallback(() => handleDateChange(addDays( /* @__PURE__ */new Date(), 1)), [handleDateChange]);
  const handleNowClick = useCallback(() => onSelect( /* @__PURE__ */new Date()), [onSelect]);
  return /* @__PURE__ */jsxs(Box, {
    "data-ui": "Calendar",
    ...restProps,
    ref,
    children: [/* @__PURE__ */jsxs(Box, {
      padding: 2,
      children: [features.dayPresets, /* @__PURE__ */jsxs(Flex, {
        children: [/* @__PURE__ */jsx(Box, {
          flex: 1,
          children: /* @__PURE__ */jsx(CalendarMonthSelect, {
            onChange: handleFocusedMonthChange,
            monthNames: labels.monthNames,
            value: focusedDate == null ? void 0 : focusedDate.getMonth()
          })
        }), /* @__PURE__ */jsx(Box, {
          marginLeft: 2,
          children: /* @__PURE__ */jsx(CalendarYearSelect, {
            moveFocusedDate,
            labels: {
              goToNextYear: labels.goToNextYear,
              goToPreviousYear: labels.goToPreviousYear
            },
            onChange: setFocusedDateYear,
            value: focusedDate.getFullYear()
          })
        })]
      }), /* @__PURE__ */jsxs(Box, {
        "data-calendar-grid": true,
        onKeyDown: handleKeyDown,
        marginTop: 2,
        overflow: "hidden",
        tabIndex: 0,
        children: [/* @__PURE__ */jsx(CalendarMonth, {
          weekDayNames: labels.weekDayNamesShort,
          date: focusedDate,
          focused: focusedDate,
          onSelect: handleDateChange,
          selected: selectedDate
        }), PRESERVE_FOCUS_ELEMENT]
      })]
    }), selectTime && /* @__PURE__ */jsxs(Box, {
      padding: 2,
      style: {
        borderTop: "1px solid var(--card-border-color)"
      },
      children: [/* @__PURE__ */jsxs(Flex, {
        align: "center",
        children: [/* @__PURE__ */jsxs(Flex, {
          align: "center",
          flex: 1,
          children: [/* @__PURE__ */jsx(Box, {
            children: /* @__PURE__ */jsx(Select, {
              "aria-label": labels.selectHour,
              fontSize: 1,
              padding: 2,
              radius: 2,
              value: selectedDate == null ? void 0 : selectedDate.getHours(),
              onChange: handleHoursChange,
              children: HOURS_24.map(h => /* @__PURE__ */jsx("option", {
                value: h,
                children: "".concat(h).padStart(2, "0")
              }, h))
            })
          }), /* @__PURE__ */jsx(Box, {
            paddingX: 1,
            children: /* @__PURE__ */jsx(Text, {
              size: 1,
              children: ":"
            })
          }), /* @__PURE__ */jsx(Box, {
            children: /* @__PURE__ */jsx(Select, {
              "aria-label": labels.selectMinute,
              fontSize: 1,
              padding: 2,
              radius: 2,
              value: selectedDate == null ? void 0 : selectedDate.getMinutes(),
              onChange: handleMinutesChange,
              children: range(0, 60, timeStep).map(m => /* @__PURE__ */jsx("option", {
                value: m,
                children: "".concat(m).padStart(2, "0")
              }, m))
            })
          })]
        }), /* @__PURE__ */jsx(Box, {
          marginLeft: 2,
          children: /* @__PURE__ */jsx(Button, {
            text: labels.setToCurrentTime,
            mode: "bleed",
            onClick: handleNowClick
          })
        })]
      }), features.timePresets]
    })]
  });
});
function CalendarMonthSelect(props) {
  const {
    onChange,
    value,
    monthNames
  } = props;
  return /* @__PURE__ */jsx(Flex, {
    flex: 1,
    gap: 1,
    children: /* @__PURE__ */jsx(Box, {
      flex: 1,
      children: /* @__PURE__ */jsx(Select, {
        fontSize: 1,
        radius: 2,
        value,
        onChange,
        padding: 2,
        children: monthNames.map((monthName, i) =>
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */
        jsx("option", {
          value: i,
          children: monthName
        }, i))
      })
    })
  });
}
function CalendarYearSelect(props) {
  const {
    moveFocusedDate,
    onChange,
    value,
    labels
  } = props;
  const handlePrevYearClick = useCallback(() => moveFocusedDate(-12), [moveFocusedDate]);
  const handleNextYearClick = useCallback(() => moveFocusedDate(12), [moveFocusedDate]);
  return /* @__PURE__ */jsxs(Flex, {
    gap: 1,
    children: [/* @__PURE__ */jsx(Button, {
      "aria-label": labels.goToPreviousYear,
      onClick: handlePrevYearClick,
      mode: "bleed",
      icon: ChevronLeftIcon,
      tooltipProps: {
        content: "Previous year"
      },
      ...CALENDAR_ICON_BUTTON_PROPS
    }), /* @__PURE__ */jsx(YearInput, {
      value,
      onChange,
      radius: 0,
      style: {
        width: 48
      }
    }), /* @__PURE__ */jsx(Button, {
      "aria-label": labels.goToNextYear,
      onClick: handleNextYearClick,
      mode: "bleed",
      icon: ChevronRightIcon,
      tooltipProps: {
        content: "Next year"
      },
      ...CALENDAR_ICON_BUTTON_PROPS
    })]
  });
}
const DatePicker = forwardRef(function DatePicker2(props, ref) {
  const {
    value = /* @__PURE__ */new Date(),
    onChange,
    calendarLabels,
    ...rest
  } = props;
  const [focusedDate, setFocusedDay] = useState();
  const handleSelect = useCallback(nextDate => {
    onChange(nextDate);
    setFocusedDay(void 0);
  }, [onChange]);
  return /* @__PURE__ */jsx(Calendar, {
    ...rest,
    labels: calendarLabels,
    ref,
    selectedDate: value,
    onSelect: handleSelect,
    focusedDate: focusedDate || value,
    onFocusedDateChange: setFocusedDay
  });
});
function isValidDate(date) {
  return date instanceof Date && !isNaN(date.valueOf());
}
function getCalendarLabels(t) {
  return {
    goToTomorrow: t("calendar.action.go-to-tomorrow"),
    goToToday: t("calendar.action.go-to-today"),
    goToYesterday: t("calendar.action.go-to-yesterday"),
    goToNextMonth: t("calendar.action.go-to-next-month"),
    goToPreviousMonth: t("calendar.action.go-to-previous-month"),
    goToNextYear: t("calendar.action.go-to-next-year"),
    goToPreviousYear: t("calendar.action.go-to-previous-year"),
    setToCurrentTime: t("calendar.action.set-to-current-time"),
    selectHour: t("calendar.action.select-hour"),
    selectMinute: t("calendar.action.select-minute"),
    monthNames: [t("calendar.month-names.january"), t("calendar.month-names.february"), t("calendar.month-names.march"), t("calendar.month-names.april"), t("calendar.month-names.may"), t("calendar.month-names.june"), t("calendar.month-names.july"), t("calendar.month-names.august"), t("calendar.month-names.september"), t("calendar.month-names.october"), t("calendar.month-names.november"), t("calendar.month-names.december")],
    weekDayNamesShort: [t("calendar.weekday-names.short.monday"), t("calendar.weekday-names.short.tuesday"), t("calendar.weekday-names.short.wednesday"), t("calendar.weekday-names.short.thursday"), t("calendar.weekday-names.short.friday"), t("calendar.weekday-names.short.saturday"), t("calendar.weekday-names.short.sunday")],
    setToTimePreset: (time, date) => t("calendar.action.set-to-time-preset", {
      time,
      date
    })
  };
}
async function getJsonStream(url, token) {
  const options = token ? {
    headers: {
      Authorization: "Bearer ".concat(token)
    }
  } : {
    credentials: "include"
  };
  const response = await fetch(url, options);
  return getStream(response);
}
function getStream(response) {
  const body = response.body;
  if (!body) {
    throw new Error("Failed to read body from response");
  }
  let reader;
  let cancelled = false;
  return new ReadableStream({
    start(controller) {
      reader = body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      reader.read().then(function processResult(result) {
        if (result.done) {
          if (cancelled) {
            return;
          }
          buffer = buffer.trim();
          if (buffer.length === 0) {
            controller.close();
            return;
          }
          controller.enqueue(JSON.parse(buffer));
          controller.close();
          return;
        }
        buffer += decoder.decode(result.value, {
          stream: true
        });
        const lines = buffer.split("\n");
        for (let i = 0; i < lines.length - 1; ++i) {
          const line = lines[i].trim();
          if (line.length === 0) {
            continue;
          }
          try {
            controller.enqueue(JSON.parse(line));
          } catch (err) {
            controller.error(err);
            cancelled = true;
            reader.cancel();
            return;
          }
        }
        buffer = lines[lines.length - 1];
        return reader.read().then(processResult).catch(err => controller.error(err));
      }).catch(err => controller.error(err));
    },
    cancel() {
      cancelled = true;
      reader.cancel();
    }
  });
}
export { Button, ConditionalWrapper, DatePicker, Dialog, LazyTextInput, LocaleContext, MenuButton, MenuGroup, MenuItem, Popover, Tab, Tooltip, TooltipDelayGroupProvider, getCalendarLabels, getJsonStream, isValidDate, useCurrentLocale, useLocale };
//# sourceMappingURL=getJsonStream-RYwhuhmq.js.map
